<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹æ©Ÿé¡é ­ AI å³æ™‚åˆ†æ</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        h2 {
            position: absolute;
            top: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 15px;
            border-radius: 20px;
            margin: 0;
        }

        #status {
            position: absolute;
            top: 50px;
            z-index: 10;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        /* è¦–è¨Šå®¹å™¨ï¼Œç”¨æ–¼é‡ç–Š Video å’Œ Canvas */
        .cam-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            height: auto;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        video {
            display: block;
            width: 100%;
            height: auto;
            /* é¡åƒç¿»è½‰ (å¦‚æœæ˜¯å‰é¡é ­éœ€è¦ï¼Œå¾Œé¡é ­é€šå¸¸ä¸éœ€è¦) */
            /* transform: scaleX(-1); */ 
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        button {
            position: absolute;
            bottom: 30px;
            z-index: 10;
            padding: 12px 24px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background-color: #ccc;
        }
    </style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨é¡é ­é¸æ“‡å™¨</title>
    <style>
        body { font-family: sans-serif; background: #222; color: white; text-align: center; padding: 20px; }
        select { padding: 10px; font-size: 16px; margin-bottom: 20px; width: 90%; max-width: 400px; }
        video { width: 100%; max-width: 640px; background: black; border: 2px solid #00ffcc; }
        #status { color: #aaa; margin-top: 10px; }
    </style>
</head>
<body>

    <h2>å¤–ç½®é¡é ­ AI åˆ†æ</h2>

    <label for="camSelect">é¸æ“‡å½±åƒä¾†æºï¼š</label><br>
    <select id="camSelect"></select>

    <br>
    <video id="video" playsinline autoplay></video>
    <div id="status">æ­£åœ¨åˆå§‹åŒ–...</div>

    <script>
        const video = document.getElementById('video');
        const select = document.getElementById('camSelect');
        const status = document.getElementById('status');
        let currentStream = null;

        async function init() {
            try {
                // 1. é‡è¦ï¼å…ˆè«‹æ±‚ä¸€æ¬¡æ¬Šé™
                // å¦‚æœä¸å…ˆåšé€™æ­¥ï¼Œç€è¦½å™¨ä¸æœƒçµ¦ä½ è£ç½®çš„ã€Œåç¨±ã€(Label)ï¼Œé¸å–®æœƒè®Šæˆç©ºçš„æˆ–åªé¡¯ç¤º "Camera 1"
                status.innerText = "è«‹æ±‚æ¬Šé™ä¸­...";
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                
                // æ¬Šé™æ‹¿åˆ°å¾Œï¼Œå…ˆæŠŠé€™å€‹æš«æ™‚çš„ä¸²æµé—œæ‰ï¼Œå…å¾—ä½”ç”¨è³‡æº
                stream.getTracks().forEach(track => track.stop());

                // 2. åˆ—å‡ºæ‰€æœ‰è£ç½®
                await listCameras();

                // 3. é è¨­å•Ÿå‹•é¸å–®è£¡çš„ç¬¬ä¸€å€‹é¡é ­
                if (select.options.length > 0) {
                    startCamera(select.value);
                } else {
                    status.innerText = "æ‰¾ä¸åˆ°ä»»ä½•æ”å½±æ©Ÿ";
                }

            } catch (err) {
                console.error(err);
                status.innerText = "éŒ¯èª¤: " + err.message;
                alert("è«‹å…è¨±ç›¸æ©Ÿæ¬Šé™ï¼Œå¦å‰‡ç„¡æ³•åµæ¸¬è£ç½®");
            }
        }

        async function listCameras() {
            // å–å¾—æ‰€æœ‰è£ç½®åˆ—è¡¨
            const devices = await navigator.mediaDevices.enumerateDevices();
            
            // éæ¿¾å‡º "videoinput" (ä¹Ÿå°±æ˜¯æ”å½±æ©Ÿ)
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            select.innerHTML = ''; // æ¸…ç©ºé¸å–®

            videoDevices.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId; // é€™æ˜¯å•Ÿå‹•é¡é ­éœ€è¦çš„ ID
                
                // é¡¯ç¤ºåç¨±é‚è¼¯ï¼šå¦‚æœæœ‰å…§å»ºåç¨±å°±ç”¨ï¼Œæ²’æœ‰å°±è‡ªå·±ç·¨è™Ÿ
                const label = device.label || `æ”å½±æ©Ÿ ${index + 1}`;
                
                // å¯ä»¥åœ¨é€™è£¡åšå€‹å°åˆ¤æ–·ï¼Œæ¨™ç¤ºå®ƒæ˜¯å“ªç¨®
                // (æ³¨æ„ï¼šä¸æ˜¯æ‰€æœ‰ç€è¦½å™¨éƒ½æœƒå›å‚³ facingMode è³‡è¨Šï¼Œä¸»è¦é  label è¾¨è­˜)
                let displayText = label;
                if (label.toLowerCase().includes('back') || label.includes('å¾Œ')) {
                    displayText = `ğŸ“· å¾Œç½®ï¼š${label}`;
                } else if (label.toLowerCase().includes('front') || label.includes('å‰')) {
                    displayText = `ğŸ‘¤ å‰ç½®ï¼š${label}`;
                } else if (label.toLowerCase().includes('usb')) {
                    displayText = `ğŸ”Œ å¤–æ¥ï¼š${label}`;
                }

                option.text = displayText;
                select.appendChild(option);
            });

            status.innerText = `åµæ¸¬åˆ° ${videoDevices.length} å€‹è£ç½®`;
            
            // ç¶å®šé¸å–®è®Šæ›´äº‹ä»¶
            select.onchange = () => {
                startCamera(select.value);
            };
        }

        async function startCamera(deviceId) {
            // 4. åˆ‡æ›å‰ï¼Œå‹™å¿…å…ˆé—œé–‰èˆŠçš„é¡é ­ï¼
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            status.innerText = "åˆ‡æ›é¡é ­ä¸­...";

            const constraints = {
                video: {
                    // é€™è£¡å°±æ˜¯é—œéµï¼šæŒ‡å®š deviceId
                    deviceId: { exact: deviceId },
                    width: { ideal: 640 }, // å»ºè­°è¨­å®šç†æƒ³è§£æåº¦ï¼Œé¿å…å¤–æ¥é¡é ­è·‘å¤ªé«˜è§£æåº¦å¡é “
                    height: { ideal: 480 }
                }
            };

            try {
                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = newStream;
                video.srcObject = newStream;
                status.innerText = "é¡é ­é‹ä½œä¸­";

        // 3. é æ¸¬å¾ªç’°
        function predictLoop() {
            // è¨­å®š Canvas å¤§å°èˆ‡ Video ä¸€è‡´
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // åŸ·è¡Œåµæ¸¬
            model.detect(video).then(predictions => {
                // æ¸…é™¤ä¸Šä¸€å¹€çš„ç¹ªåœ–
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç¹ªè£½æ–°çš„åµæ¸¬çµæœ
                renderPredictions(predictions);
                
                // ä½¿ç”¨ requestAnimationFrame é€²è¡Œä¸‹ä¸€å¹€é æ¸¬
                requestAnimationFrame(predictLoop);
            });
        }

        // 4. ç¹ªè£½æ¡†ç·šèˆ‡æ¨™ç±¤
        function renderPredictions(predictions) {
            ctx.font = '16px Arial';
            ctx.textBaseline = 'top';

            predictions.forEach(prediction => {
                const x = prediction.bbox[0];
                const y = prediction.bbox[1];
                const width = prediction.bbox[2];
                const height = prediction.bbox[3];

                // ç•«æ¡†æ¡†
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, width, height);

                // ç•«èƒŒæ™¯è‰²å¡Š (æ–‡å­—åº•åœ–)
                ctx.fillStyle = '#00FFFF';
                const textWidth = ctx.measureText(prediction.class).width;
                ctx.fillRect(x, y, textWidth + 10, 25);

                // ç•«æ–‡å­—
                ctx.fillStyle = '#000000';
                ctx.fillText(prediction.class + ` (${Math.round(prediction.score * 100)}%)`, x + 5, y + 5);
            });
        }
    </script>
</body>
</html>
