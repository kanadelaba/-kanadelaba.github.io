<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹æ©Ÿé¡é ­ AI å³æ™‚åˆ†æ (å«é¡é ­é¸æ“‡)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        /* ç‹€æ…‹åˆ— */
        #status {
            position: absolute;
            top: 20px;
            z-index: 20;
            color: #00ffcc;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none; /* è®“é»æ“Šç©¿é€ */
        }

        /* é¡é ­é¸æ“‡é¸å–®å®¹å™¨ */
        #selectContainer {
            position: absolute;
            top: 70px; /* æ”¾åœ¨ç‹€æ…‹åˆ—ä¸‹æ–¹ */
            z-index: 20;
            display: none; /* ä¸€é–‹å§‹éš±è—ï¼Œç­‰æœ‰æ¬Šé™å†é¡¯ç¤º */
        }

        select {
            padding: 8px 15px;
            border-radius: 20px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            outline: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* è¦–è¨Šå®¹å™¨ */
        .cam-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            height: auto;
            overflow: hidden;
            display: flex;
            justify-content: center;
            background: #000;
        }

        video {
            display: block;
            width: 100%;
            height: auto;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        button {
            position: absolute;
            bottom: 40px;
            z-index: 30;
            padding: 15px 30px;
            font-size: 18px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: background 0.3s;
        }
        
        button:disabled {
            background-color: #555;
            color: #aaa;
        }
    </style>
</head>
<body>

    <div id="status">ç­‰å¾…å•Ÿå‹•...</div>

    <div id="selectContainer">
        <select id="cameraSelect" onchange="changeCamera()"></select>
    </div>

    <div class="cam-container">
        <video id="webcam" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
    </div>

    <button id="startBtn" onclick="startApp()">é–‹å•Ÿç›¸æ©Ÿä¸¦åˆ†æ</button>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const selectContainer = document.getElementById('selectContainer');
        const cameraSelect = document.getElementById('cameraSelect');
        
        let model = undefined;
        let currentStream = null;
        let isPredicting = false;

        // 1. å•Ÿå‹•æ‡‰ç”¨ç¨‹å¼ä¸»å…¥å£
        async function startApp() {
            startBtn.disabled = true;
            statusDiv.innerText = "è¼‰å…¥ AI æ¨¡å‹ä¸­... (é¦–æ¬¡éœ€å¹¾ç§’)";
            
            try {
                // è¼‰å…¥ COCO-SSD æ¨¡å‹
                model = await cocoSsd.load();
                statusDiv.innerText = "æ¨¡å‹è¼‰å…¥å®Œæˆï¼Œæ­£åœ¨è«‹æ±‚ç›¸æ©Ÿæ¬Šé™...";
                
                // åˆæ¬¡å•Ÿå‹• (é è¨­å¾Œé¡é ­)
                await setupCamera();
                
                // æ¬Šé™æ‹¿åˆ°å¾Œï¼Œåˆ—å‡ºæ‰€æœ‰é¡é ­ä¸¦å¡«å…¥é¸å–®
                await populateCameraList();
                
                // é¡¯ç¤ºé¸å–®èˆ‡éš±è—æŒ‰éˆ•
                selectContainer.style.display = 'block';
                startBtn.style.display = 'none';
                
                // é–‹å§‹é æ¸¬
                video.play();
                statusDiv.innerText = "æ­£åœ¨åˆ†æç•«é¢...";
                
                if (!isPredicting) {
                    isPredicting = true;
                    predictLoop();
                }

            } catch (err) {
                console.error(err);
                statusDiv.innerText = "éŒ¯èª¤: " + err.message;
                startBtn.disabled = false;
                startBtn.innerText = "é‡è©¦";
            }
        }

        // 2. è¨­å®š/åˆ‡æ›ç›¸æ©Ÿçš„æ ¸å¿ƒå‡½å¼
        async function setupCamera(deviceId = null) {
            // å¦‚æœå·²ç¶“æœ‰ä¸²æµåœ¨è·‘ï¼Œå…ˆåœæ­¢å®ƒ
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            // è¨­å®šåƒæ•¸
            const constraints = {
                audio: false,
                video: {
                    // å¦‚æœæœ‰æŒ‡å®š ID å°±ç”¨ IDï¼Œæ²’æœ‰å°±é è¨­ 'environment' (å¾Œé¡é ­)
                    deviceId: deviceId ? { exact: deviceId } : undefined,
                    facingMode: deviceId ? undefined : 'environment',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };

            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            currentStream = stream;
            video.srcObject = stream;
            
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    resolve(video);
                };
            });
        }

        // 3. åˆ—å‡ºæ‰€æœ‰é¡é ­ä¸¦è£½ä½œé¸å–®
        async function populateCameraList() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            cameraSelect.innerHTML = ""; // æ¸…ç©º

            videoDevices.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                
                // ç¾åŒ–åç¨±
                const label = device.label || `æ”å½±æ©Ÿ ${index + 1}`;
                let displayText = label;
                
                if (label.toLowerCase().includes('back') || label.includes('å¾Œ')) {
                    displayText = `ğŸ“· å¾Œç½®ï¼š${label}`;
                } else if (label.toLowerCase().includes('front') || label.includes('å‰')) {
                    displayText = `ğŸ‘¤ å‰ç½®ï¼š${label}`;
                } else if (label.toLowerCase().includes('usb')) {
                    displayText = `ğŸ”Œ å¤–æ¥ï¼š${label}`;
                }

                option.text = displayText;
                cameraSelect.appendChild(option);
            });

            // å˜—è©¦å°‡é¸å–®é¸ä¸­ç•¶å‰ä½¿ç”¨çš„é¡é ­ (å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ï¼Œé€šå¸¸æ˜¯å¾Œé¡é ­)
            const currentTrack = currentStream.getVideoTracks()[0];
            const currentDeviceId = currentTrack.getSettings().deviceId;
            if (currentDeviceId) {
                cameraSelect.value = currentDeviceId;
            }
        }

        // 4. ä½¿ç”¨è€…åˆ‡æ›é¸å–®æ™‚è§¸ç™¼
        async function changeCamera() {
            const deviceId = cameraSelect.value;
            statusDiv.innerText = "åˆ‡æ›é¡é ­ä¸­...";
            
            try {
                await setupCamera(deviceId);
                video.play();
                statusDiv.innerText = "é¡é ­å·²åˆ‡æ›ï¼Œç¹¼çºŒåˆ†æ";
            } catch (err) {
                console.error(err);
                statusDiv.innerText = "åˆ‡æ›å¤±æ•—: " + err.message;
            }
        }

        // 5. é æ¸¬å¾ªç’°
        function predictLoop() {
            // ç¢ºä¿å½±ç‰‡æœ‰åœ¨æ’­æ”¾ä¸”å¯¬åº¦å¤§æ–¼0æ‰åŸ·è¡Œ
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                
                // è¨­å®š Canvas å¤§å°èˆ‡ Video ä¸€è‡´
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // åŸ·è¡Œåµæ¸¬
                model.detect(video).then(predictions => {
                    // æ¸…é™¤ä¸Šä¸€å¹€çš„ç¹ªåœ–
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // ç¹ªè£½æ–°çš„åµæ¸¬çµæœ
                    renderPredictions(predictions);
                    
                    // ä¸‹ä¸€å¹€
                    requestAnimationFrame(predictLoop);
                });
            } else {
                // å¦‚æœå½±ç‰‡é‚„æ²’æº–å‚™å¥½ï¼Œç¨ç­‰ä¸€ä¸‹å†è©¦
                requestAnimationFrame(predictLoop);
            }
        }

        // 6. ç¹ªè£½æ¡†ç·šèˆ‡æ¨™ç±¤
        function renderPredictions(predictions) {
            ctx.font = '16px Arial';
            ctx.textBaseline = 'top';

            predictions.forEach(prediction => {
                const x = prediction.bbox[0];
                const y = prediction.bbox[1];
                const width = prediction.bbox[2];
                const height = prediction.bbox[3];

                // ç•«æ¡†æ¡†
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, width, height);

                // ç•«èƒŒæ™¯è‰²å¡Š (æ–‡å­—åº•åœ–)
                ctx.fillStyle = '#00FFFF';
                const textWidth = ctx.measureText(prediction.class).width;
                ctx.fillRect(x, y, textWidth + 10, 25);

                // ç•«æ–‡å­—
                ctx.fillStyle = '#000000';
                ctx.fillText(prediction.class + ` (${Math.round(prediction.score * 100)}%)`, x + 5, y + 5);
            });
        }
    </script>
</body>
</html>
